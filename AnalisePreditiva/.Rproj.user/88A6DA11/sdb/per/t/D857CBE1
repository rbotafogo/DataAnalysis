{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Build a Model\"\noutput: html_notebook\n---\n\n```{r setup, include=FALSE}\nlibrary(tidyverse)\nlibrary(modelr)\noptions(na.action = na.warn)\n```\n\nOs dados em sim1 são dados simulados e vamos iniciar olhando os dados através de um \"scatterplot\".\n\n```{r sim1_scatter}\nggplot(sim1, aes(x = x, y = y)) + geom_point()\n```\n\nPodemos observar que há um forte relacionamento linear entre as varáveis \"x\" e \"y\".  Vamos tentar capturar este relacionamento linear. Inicialmente vamos gerar 250 modelos diferente aleatórios e plotar todos os modelos por cima dos nossos dados. Para plotar todos os modelos vamos usar geom_abline passando a interseção e a inclinação.\n\n```{r}\nmodels = tibble (\n  a1 = runif(250, -20, 40),\n  a2 = runif(250, -5, 5)\n)\n\nggplot(sim1, aes(x = x, y = y)) + \n  geom_abline(aes(intercept = a1, slope = a2), \n              data = models, alpha = 1/4) +\n  geom_point()\n```\n\n```{r model1}\n# Função model1 pega o valor de x de 'data' e calcula o valor de y corresponde no modelo\nmodel1 = function(a, data) {\n  a[1] + data$x * a[2]\n}\n\n# exemplo de como chamar a função model1, passando os valores de interseção e coeficiente\nmodel1(c(7, 1.5), sim1)\n```\n\n\n```{r measure_distance}\nmeasure_distance = function(mod, data) {\n  diff = data$y - model1(mod, data)\n  sqrt(mean(diff ^ 2))\n}\n\nmeasure_distance(c(7,1.5), sim1)\n```\n\n```{r sim1_dist}\n# mede a distância entre um modelo dados por interseção e coeficiente para os dados em sim1\nsim1_dist = function(intersept, slope) {\n  measure_distance(c(intersept, slope), sim1)\n}\n\n# verifica a distância de todos os modelos criados para os dados em sim1\nmodels = models %>%\n  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))\n\nmodels\n```\n\n```{r 10_best}\nggplot(sim1, aes(x, y)) +\n  # colocar os pontos dos dados com tamanho 2 e cor especificada\n  geom_point(size = 2, color = \"grey30\") +\n  # adicionar as 10 primeiras ablines \n  geom_abline(aes(intercept = a1, slope = a2, color = -dist), \n              data = filter(models, rank(dist) <= 10))\n\n```\n\nVamos fazer um grid de pontos em vez de gerar os pontos do modelo aleatoriamente e plotar os 10 melhores modelos.\n\n```{r grid}\ngrid = expand.grid(\n  a1 = seq(-5, 20, length = 25),\n  a2 = seq(1, 3, length = 25)\n) %>%\n  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))\n\ngrid %>%\n  ggplot(aes(a1, a2)) + \n  geom_point(data = filter(grid, rank(dist) <= 10), \n             color = \"red\", size = 4) +\n  geom_point(aes(color = -dist))\n```\n\nAgora vamos sobrepor os 10 melhores modelos em cima dos dados originais\n```{r}\nggplot(sim1, aes(x, y)) +\n  geom_point() +\n  geom_abline(data = filter(grid, rank(dist) <= 10),\n              aes(intercept = a1, slope = a2, color = -dist))\n```\n\nUtilizando a função lm do base R para encontrar o melhor modelo linear para estes pontos\n\n```{r}\nsim1_lm_fit = lm(y ~ x, data = sim1)\ncoef(sim1_lm_fit)\n```\n\nVamos plotar este modelo em cima dos dados\n\n```{r}\nsim1 %>% \n  ggplot(aes(x, y)) + geom_point() +\n  geom_abline(intercept = coef(sim1_lm_fit)[[1]], \n              slope = coef(sim1_lm_fit)[[2]], color = \"red\")\n```\n\n# Visualizando um Modelo\n\nAté o presente momento, utilizamos geom_abline para visualizar o resultado de nossa previsão. Esta solução é bastante simples e limitada a modelos lineares que podem ser facilmente visualizados.  Vamos agora utilizar uma metodologia mais genérica que se aplica a qualquer modelo, não somente a modelos lineares.\n\nInicialmente cria-se uma grade para inserção dos dados da previsão\n\n```{r}\ngrid = sim1 %>% data_grid(x)\ngrid\n```\n\nAgora adicionamos à grade os valores obtidos na previsão\n\n```{r}\ngrid = grid %>% add_predictions(sim1_lm_fit)\ngrid\n```\n\nE finalmente, podemos visualizar o resultado do modelo através de um gráfico.  Neste momento, o gráfico é o mesmo já obtido anteriormente através do geom_abline.  Veremos adiante que esta metodologia é mais genérica\n\n```{r}\nsim1 %>%\n  ggplot(aes(x, y)) + geom_point() +\n  geom_line(data = grid, aes(y = pred), color = \"red\")\n```\n\n## Residuais\n\nDando continuidade à visualização do modelo, vamos agora analisar os dados residuais.  Os residuais são o \"erro\" não capturado pelo modelo, dado, neste modelo, pela distância dos pontos estimados até os pontos reais.  Neste caso, os residuais são adicionados aos dados originais e não na grade, pois para adicionar os residuais é necessário ter a informação dos dados reais\n\n```{r residuals}\nsim1 = sim1 %>%\n  add_residuals(sim1_lm_fit)\nsim1\n```\n\nVamos verificar as frequências do residual\n\n```{r}\nsim1 %>%\n  ggplot(aes(resid)) + geom_freqpoly(binwidth = 0.5)\n  \n```\n\nVamos agora plotar o grpafico do residual no lugar do valor de y, ou seja, estamos olhando o gráfico das previsões \"sem a tendência\" calculada pelo modelo\n\n```{r}\nsim1 %>%\n  ggplot(aes(x, resid)) +\n  geom_ref_line(h = 0) +\n  geom_point()\n```\nObservamos que os residuais paracem distribuidos aleatoriamente, o que indica que a previsão feita anteriormente captura a maioria da tendência.\n\n## Formulas\n\n```{r}\ndf = tribble(\n  ~ sex, ~ response,\n  \"male\", 1,\n  \"female\", 0,\n  \"male\", 1\n)\n\nmodel_matrix(df, response ~ sex)\n```\n\nVamos fazer as mesmas etapas feitas anteriormente agora com outro modelo que contém variáveis de categoria.\n\n```{r}\nsim2_lm_fit = lm(y ~ x, data = sim2)\n```\n\n```{r}\nsim2 %>%\n  ggplot(aes(x, y)) + geom_point()\n```\n\n```{r}\ngrid2 = sim2 %>% data_grid(x)\ngrid2 = grid2 %>% add_predictions(sim2_lm_fit)\ngrid2\n```\n\n```{r}\nsim2 %>%\n  ggplot(aes(x, y)) + geom_point() + \n  geom_point(data = grid2, aes(y = pred), color = \"red\", size = 4)\n```\n\nVamos verificar um terceiro modelo\n\n```{r}\nsim3 %>% ggplot(aes(x1, y)) + geom_point(aes(color = x2))\n\nsim3_lm_fit1 = lm(data = sim3, y ~ x1 + x2)\nsim3_lm_fit1\n\nsim3_lm_fit2 = lm(data = sim3, y ~ x1 * x2)\nsim3_lm_fit2\n```\n\n```{r}\ngrid3 = sim3 %>% data_grid(x1, x2)\ngrid3 = grid3 %>% gather_predictions(sim3_lm_fit1, sim3_lm_fit2)\ngrid3\n```\n\n```{r}\nsim3 %>% ggplot(aes(x1, y, color = x2)) + geom_point() +\n  geom_line(data = grid3, aes(y = pred)) + facet_wrap(~ model)\n  \n```\n\n```{r}\nsim3_1 = sim3 %>% filter(x2 == \"d\")\nsim3_1_lm_fit = lm(data = sim3_1, y ~ x1)\nsim3_1 %>%\n  ggplot(aes(x1, y)) + geom_point() +\n  geom_abline(intercept = coef(sim3_1_lm_fit)[[1]], \n              slope = coef(sim3_1_lm_fit)[[2]], color = \"red\")\n```\n```{r}\nsim3_1_lm_fit\n```\n\n",
    "created" : 1512393759655.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3871682442",
    "id" : "D857CBE1",
    "lastKnownWriteTime" : 1513875320,
    "last_content_update" : 1513875318795,
    "path" : "T:/Rodrigo/DataAnalysis/AnalisePreditiva/BuildModel.Rmd",
    "project_path" : "BuildModel.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "last_setup_crc32" : ""
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}